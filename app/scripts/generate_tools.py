"""
Generate JSON tool configs for the Micro SaaS Factory.

Usage (single):
  python scripts/generate_tools.py --topic "aquarium salinity" --mock
  python scripts/generate_tools.py --topic "cat age converter" --slug cat-age --force

Usage (batch from file, 1 topic per line):
  python scripts/generate_tools.py --topics-file scripts/topics.txt --max-per-day 20 --shuffle

Usage (strategy mode - let Gemini pick niches and formulas):
  python scripts/generate_tools.py --strategy --plan-count 20 --max-per-day 20

Notes:
- Install google-generativeai and set GEMINI_API_KEY to use Gemini; otherwise use --mock.
- Batch mode respects --max-per-day, skips existing slugs unless --force.
- Writes an optional CSV log with date/slug/title/path for tracking.
"""

from __future__ import annotations

import argparse
import json
import os
import random
import re
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Iterable, List

ROOT = Path(__file__).resolve().parents[1]
TOOLS_DIR = ROOT / "data" / "tools"
LOG_FILE = ROOT / "data" / "tool_generation_log.csv"


@dataclass
class ToolConfig:
  slug: str
  title: str
  seo: Dict[str, str]
  inputs: List[Dict[str, Any]]
  outputs: List[Dict[str, Any]]
  formula: str
  summary: str | None = None
  cta: str | None = None
  faq: List[Dict[str, str]] | None = None
  tags: List[str] | None = None

  def to_dict(self) -> Dict[str, Any]:
    data: Dict[str, Any] = {
        "slug": self.slug,
        "title": self.title,
        "seo": self.seo,
        "inputs": self.inputs,
        "outputs": self.outputs,
        "formula": self.formula,
    }
    if self.summary:
      data["summary"] = self.summary
    if self.cta:
      data["cta"] = self.cta
    if self.faq:
      data["faq"] = self.faq
    if self.tags:
      data["tags"] = self.tags
    return data


def sanitize_slug(text: str) -> str:
  slug = re.sub(r"[^a-zA-Z0-9]+", "-", text).strip("-").lower()
  return slug or f"tool-{random.randint(1000, 9999)}"


def ensure_dirs() -> None:
  TOOLS_DIR.mkdir(parents=True, exist_ok=True)
  LOG_FILE.parent.mkdir(parents=True, exist_ok=True)


def mock_tool(topic: str) -> ToolConfig:
  slug = sanitize_slug(topic)
  title = topic.title()
  return ToolConfig(
      slug=slug,
      title=f"{title} Calculator",
      seo={
          "title": f"{title} Calculator | Auto-generated",
          "description": f"Instant {topic} calculator generated by the factory mock mode.",
      },
      summary=f"Quick calculator for {topic} (mock generator output).",
      inputs=[
          {
              "id": "value",
              "label": "Base value",
              "type": "number",
              "placeholder": "10",
              "required": True,
          },
          {
              "id": "multiplier",
              "label": "Multiplier",
              "type": "number",
              "placeholder": "1.5",
              "required": True,
          },
      ],
      outputs=[
          {
              "id": "result",
              "label": "Result",
              "unit": "units",
              "precision": 2,
          }
      ],
      formula="const result = value * multiplier; return { result };",
      cta="Calculate",
      faq=[
          {
              "q": "Is this a mock tool?",
              "a": "Yes. Install google-generativeai and drop --mock to generate live tools.",
          }
      ],
      tags=[topic.split(" ")[0]],
  )


def generate_with_gemini(topic: str, api_key: str) -> ToolConfig:
  try:
    import google.generativeai as genai  # type: ignore
  except ImportError:
    raise RuntimeError(
        "google-generativeai is not installed. Run `pip install google-generativeai` or use --mock."
    )

  genai.configure(api_key=api_key)
  prompt = f"""You are generating a JSON config for a calculator about "{topic}".
Return only valid JSON with fields: slug, title, seo{{title,description}}, summary,
inputs[id,label,type(number|text),placeholder,required,step?], outputs[id,label,unit?,precision?],
formula (JavaScript body returning an object), cta, faq(list of {{q,a}}), tags(list of strings).
Constraints for usefulness (avoid trivial multiplier calculators):
- 3-8 inputs, at least 2 outputs. Use realistic domain units and steps.
- Include validation hints in placeholders/labels (e.g., ranges, units).
- Formula must include multiple operations (not just single multiply/divide), e.g., ratios, exponent, conditionals (ternary) or piecewise logic.
- Prefer domain-specific structure (e.g., HVAC BTU, mortgage, dosage mg/kg with caps, solar geometry, brewing gravities).
- FAQ must include at least 2 helpful items.
- Slug must be URL-safe (lowercase, hyphenated)."""
  model = genai.GenerativeModel("gemini-1.5-flash")
  response = model.generate_content(prompt)
  payload = response.text or "{}"
  data = json.loads(payload)
  slug = data.get("slug") or sanitize_slug(topic)
  data["slug"] = slug
  return ToolConfig(
      slug=data["slug"],
      title=data["title"],
      seo=data["seo"],
      summary=data.get("summary"),
      inputs=data["inputs"],
      outputs=data["outputs"],
      formula=data["formula"],
      cta=data.get("cta"),
      faq=data.get("faq"),
      tags=data.get("tags"),
  )


def plan_topics_with_gemini(api_key: str, plan_count: int, niches: str) -> List[str]:
  try:
    import google.generativeai as genai  # type: ignore
  except ImportError:
    raise RuntimeError(
        "google-generativeai is not installed. Run `pip install google-generativeai`."
    )

  genai.configure(api_key=api_key)
  prompt = f"""Act as a market research agent for calculator tools.
First, list 10 niche micro-tool markets where Google AdSense CPC is high but search competition is low.
Then, pick ONE best domain among these: {niches}.
For the chosen domain, return a JSON array of {plan_count} calculator ideas (short slugs/titles), focusing on high-need formulas (not trivial multipliers).
Format strictly as JSON array of strings, no extra text."""
  model = genai.GenerativeModel("gemini-1.5-flash")
  response = model.generate_content(prompt)
  text = response.text or "[]"
  try:
    topics = json.loads(text)
    if not isinstance(topics, list):
      raise ValueError("Plan result is not a list")
    topics = [str(t) for t in topics][:plan_count]
    return topics
  except Exception:
    print("Warning: could not parse strategy plan JSON, got:", text[:200])
    return []


def validate(config: ToolConfig) -> None:
  if not config.slug or not re.match(r"^[a-z0-9]+(-[a-z0-9]+)*$", config.slug):
    raise ValueError("Slug must be lowercase and URL safe.")
  for field in ("title", "seo"):
    if not getattr(config, field):
      raise ValueError(f"{field} is required")
  if not config.inputs:
    raise ValueError("At least one input is required")
  if not config.outputs:
    raise ValueError("At least one output is required")
  if not config.formula:
    raise ValueError("Formula is required")


def save_config(config: ToolConfig, force: bool = False) -> Path:
  ensure_dirs()
  target = TOOLS_DIR / f"{config.slug}.json"
  if target.exists() and not force:
    raise FileExistsError(f"{target} already exists. Use --force to overwrite.")
  with target.open("w", encoding="utf-8") as fh:
    json.dump(config.to_dict(), fh, indent=2, ensure_ascii=False)
    fh.write("\n")
  return target


def append_log(slug: str, title: str, path: Path) -> None:
  ensure_dirs()
  header_needed = not LOG_FILE.exists()
  with LOG_FILE.open("a", encoding="utf-8") as fh:
    if header_needed:
      fh.write("timestamp_utc,slug,title,path\n")
    fh.write(f"{datetime.utcnow().isoformat(timespec='seconds')}Z,{slug},{title},{path}\n")


def iter_topics_from_file(path: Path) -> Iterable[str]:
  with path.open("r", encoding="utf-8") as fh:
    for line in fh:
      topic = line.strip()
      if topic:
        yield topic


def main(argv: list[str] | None = None) -> int:
  parser = argparse.ArgumentParser(description="Generate tool JSON configs.")
  parser.add_argument("--topic", help="Single domain or calculator idea.")
  parser.add_argument(
      "--slug",
      help="Optional slug override. Defaults to a slugified topic.",
  )
  parser.add_argument(
      "--mock",
      action="store_true",
      help="Use the built-in mock generator (no external API calls).",
  )
  parser.add_argument(
      "--force",
      action="store_true",
      help="Overwrite existing file if the slug already exists.",
  )
  parser.add_argument(
      "--topics-file",
      type=Path,
      help="Path to a file with one topic per line (batch mode).",
  )
  parser.add_argument(
      "--max-per-day",
      type=int,
      default=20,
      help="Max items to generate in this run (batch or strategy).",
  )
  parser.add_argument(
      "--log",
      action="store_true",
      help="Append a CSV log entry for each generated tool.",
  )
  parser.add_argument(
      "--shuffle",
      action="store_true",
      help="Shuffle topics in batch mode to vary daily generation.",
  )
  parser.add_argument(
      "--strategy",
      action="store_true",
      help="Let Gemini plan niches and formulas; requires GEMINI_API_KEY.",
  )
  parser.add_argument(
      "--plan-count",
      type=int,
      default=20,
      help="How many topics to request in strategy mode.",
  )
  parser.add_argument(
      "--niches",
      type=str,
      default="gardening, finance, health",
      help="Comma-separated niches to bias strategy selection.",
  )
  args = parser.parse_args(argv)

  if not args.topic and not args.topics_file and not args.strategy:
    parser.error("Provide --topic or --topics-file or --strategy")

  api_key = os.environ.get("GEMINI_API_KEY")

  def build_and_save(topic: str) -> Path | None:
    slug = sanitize_slug(args.slug or topic)
    if args.mock or not api_key:
      config = mock_tool(topic)
      config.slug = slug
    else:
      config = generate_with_gemini(topic, api_key)
      config.slug = slug
    validate(config)
    try:
      path = save_config(config, force=args.force)
    except FileExistsError as e:
      print(f"Skip existing {slug}: {e}")
      return None
    if args.log:
      append_log(config.slug, config.title, path)
    print(
        f"Saved {config.title} to {path} at {datetime.utcnow().isoformat(timespec='seconds')}Z"
    )
    return path

  topics: List[str] = []
  if args.strategy:
    if not api_key:
      raise RuntimeError("Strategy mode requires GEMINI_API_KEY")
    topics = plan_topics_with_gemini(api_key, args.plan_count, args.niches)
    if args.shuffle:
      random.shuffle(topics)
    print(f"Planned {len(topics)} topics via strategy.")
  elif args.topics_file:
    topics = list(iter_topics_from_file(args.topics_file))
    if args.shuffle:
      random.shuffle(topics)
  elif args.topic:
    topics = [args.topic]

  generated = 0
  for topic in topics:
    if generated >= args.max_per_day:
      print(f"Reached daily cap ({args.max_per_day}), stopping.")
      break
    path = build_and_save(topic)
    if path:
      generated += 1
  print(f"Complete. Generated: {generated}/{len(topics)} (cap {args.max_per_day}).")

  return 0


if __name__ == "__main__":
  sys.exit(main())
